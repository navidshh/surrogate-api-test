name: Docker Hub CI and Deploy to ECS on Release
run-name: Deploy ${{ github.event_name == 'workflow_dispatch' && inputs.version || github.ref_name }}

on:
  # This workflow will ONLY run when a tag is pushed.
  # Pull requests are handled by a separate, simpler workflow if needed.
  workflow_dispatch:
    inputs:
      version:
        description: "Docker tag / Release version (e.g. v1.2.3)"
        required: true    
  push:
    tags:
      - 'v*.*.*' # Recommended: Use a 'v' prefix for version tags, e.g., v1.2.0
      - '*.*.*'  # Also supports tags without a 'v', e.g., 1.2.0

jobs:
  build-and-push: # Renamed for clarity
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Determine Docker tag
        id: tag
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "value=${{ inputs.version }}" >> $GITHUB_OUTPUT
          else
            # Strip leading 'v' if you prefer clean semver tags (optional)
            TAG=${{ github.ref_name }}
            echo "value=${TAG#v}" >> $GITHUB_OUTPUT
          fi            

      - name: Build and push Docker image to Docker Hub
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.aws
          push: true
          # This correctly uses the Git tag (e.g., "v1.2.0") as the Docker tag
          # tags: $ {{ secrets.DOCKER_USERNAME }}/$ {{ github.event.repository.name }}:$ {{ github.ref_name }}
          tags: ${{ secrets.DOCKER_USERNAME }}/${{ github.event.repository.name }}:${{ steps.tag.outputs.value }}

  deploy-to-ecs:
    runs-on: ubuntu-latest
    # This job depends on the build job finishing successfully
    needs: build-and-push
    permissions:
      id-token: write  # Required for OIDC
      contents: read    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Determine Docker tag
        id: tag
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "value=${{ inputs.version }}" >> $GITHUB_OUTPUT
          else
            # Strip leading 'v' if you prefer clean semver tags (optional)
            TAG=${{ github.ref_name }}
            echo "value=${TAG#v}" >> $GITHUB_OUTPUT
          fi            

      - name: Deploy to Amazon ECS
        run: |
          # Set variables
          CLUSTER_NAME=${{ secrets.ECS_CLUSTER_NAME }}
          SERVICE_NAME=${{ secrets.ECS_SERVICE_NAME }}
          TASK_FAMILY=${{ secrets.ECS_TASK_FAMILY }}      

          # This directly gets the tag that triggered the workflow (e.g., "1.1.4")
          # NEW_IMAGE_URI="$ {{ secrets.DOCKER_USERNAME }}/$ {{ github.event.repository.name }}:$ {{ github.ref_name }}"
          NEW_IMAGE_URI="${{ secrets.DOCKER_USERNAME }}/${{ github.event.repository.name }}:${{ steps.tag.outputs.value }}"

          echo "Deploying new image to ECS: $NEW_IMAGE_URI"
          
          # 1. Get the current task definition and save it to a file.
          # This is more robust than using a shell variable.
          aws ecs describe-task-definition --task-definition $TASK_FAMILY > task-definition.json

          # 2. Create a new definition file.
          # This jq command filters the '.taskDefinition' object, updates the image,
          # and removes ALL keys that are invalid for registration.
          jq --arg IMAGE_URI "$NEW_IMAGE_URI" \
            --arg COGNITO_REGION "${{ secrets.COGNITO_REGION }}" \
            --arg COGNITO_USER_POOL_ID "${{ secrets.COGNITO_USER_POOL_ID }}" \
            --arg COGNITO_APP_CLIENT_ID "${{ secrets.COGNITO_APP_CLIENT_ID }}" \
            --arg COGNITO_APP_PUBLIC_CLIENT_ID "${{ secrets.COGNITO_APP_PUBLIC_CLIENT_ID }}" \
            --arg COGNITO_APP_CLIENT_SECRET "${{ secrets.COGNITO_APP_CLIENT_SECRET }}" \
            --arg COGNITO_DOMAIN "${{ secrets.COGNITO_DOMAIN }}" \
            --arg APP_BASE_URL "${{ secrets.APP_BASE_URL }}" \
            --arg VERSION_STRING "${{ secrets.VERSION_STRING }}" \
            --arg REDIS_ENDPOINT "${{secrets.REDIS_ENDPOINT}}" \
            --arg REDIS_PORT "${{secrets.REDIS_PORT}}" \
          '
          .taskDefinition
          | .containerDefinitions[0].image = $IMAGE_URI
          | .containerDefinitions[0].environment |= (
              map(select(.name != "COGNITO_REGION" and
                        .name != "COGNITO_USER_POOL_ID" and
                        .name != "COGNITO_APP_CLIENT_ID" and
                        .name != "COGNITO_APP_PUBLIC_CLIENT_ID" and
                        .name != "COGNITO_APP_CLIENT_SECRET" and
                        .name != "COGNITO_DOMAIN" and
                        .name != "APP_BASE_URL" and
                        .name != "VERSION_STRING" and
                        .name != "REDIS_ENDPOINT" and
                        .name != "REDIS_PORT"
              ))
              + [
                  {name: "COGNITO_REGION", value: $COGNITO_REGION},
                  {name: "COGNITO_USER_POOL_ID", value: $COGNITO_USER_POOL_ID},
                  {name: "COGNITO_APP_CLIENT_ID", value: $COGNITO_APP_CLIENT_ID},
                  {name: "COGNITO_APP_PUBLIC_CLIENT_ID", value: $COGNITO_APP_PUBLIC_CLIENT_ID},
                  {name: "COGNITO_APP_CLIENT_SECRET", value: $COGNITO_APP_CLIENT_SECRET},
                  {name: "COGNITO_DOMAIN", value: $COGNITO_DOMAIN},
                  {name: "APP_BASE_URL", value: $APP_BASE_URL},
                  {name: "VERSION_STRING", value: $VERSION_STRING},
                  {name: "REDIS_ENDPOINT", value: $REDIS_ENDPOINT},
                  {name: "REDIS_PORT", value: $REDIS_PORT}
                ]
          )
          | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy, .tags)
          ' task-definition.json > new-task-definition.json

          
          # 3. Register the new task definition using the clean file.
          # The 'file://' prefix is the standard way to pass JSON input.
          # It avoids issues with shell quoting and special characters.
          NEW_TASK_INFO=$(aws ecs register-task-definition --cli-input-json file://new-task-definition.json)
          NEW_REVISION_ARN=$(echo $NEW_TASK_INFO | jq -r '.taskDefinition.taskDefinitionArn')

          # 4. Update the service to use the new task definition revision.
          echo "Updating ECS service to use new revision: $NEW_REVISION_ARN"
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --task-definition $NEW_REVISION_ARN \
            --force-new-deployment
          
          echo "Deployment initiated successfully."